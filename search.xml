<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/googleb6aeb1d5b1eae55a/"/>
      <url>/googleb6aeb1d5b1eae55a/</url>
      
        <content type="html"><![CDATA[google-site-verification: googleb6aeb1d5b1eae55a.html<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>freertos-5</title>
      <link href="/freertos-5/"/>
      <url>/freertos-5/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从单片机到操作系统-4</title>
      <link href="/freertos-4/"/>
      <url>/freertos-4/</url>
      
        <content type="html"><![CDATA[<p>大家晚上好，我是杰杰，最近挺忙的，好久没有更新了，今天周末就吐血更新一下吧！</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>FreeRTOS</code>是一个是实时内核，任务是程序执行的最小单位，也是调度器处理的基本单位，移植了<code>FreeRTOS</code>，则避免不了对任务的管理，在多个任务运行的时候，任务切换显得尤为重要。而任务切换的效率会决定了系统的稳定性与效率。</p><p><code>FreeRTOS</code>的任务切换是干嘛的呢，<code>rtos</code>的实际是永远运行的是具有最高优先级的运行态任务，而那些之前在就绪态的任务怎么变成运行态使其得以运行呢，这就是我们<code>FreeRTOS</code>任务切换要做的事情，它要做的是找到最高优先级的就绪态任务，并且让它获得cpu的使用权，这样，它就能从就绪态变成运行态，这样子，整个系统的实时性就会很好，响应也会很好，而不会让程序阻塞卡死。</p><p>要知道怎么实现任务切换，那就要知道任务切换的机制，在不同的<code>cpu（mcu）</code>中，触发的方式可能会不一样，现在是以Cortex-M3为例来讲讲任务的切换。为了大家能看懂本文，我就抛转引玉一下，<code>引用《Cortex-M3权威指南-中文版》的部分语句（如涉及侵权，请联系杰杰删除）</code></p><h1 id="SVC-和-PendSV"><a href="#SVC-和-PendSV" class="headerlink" title="SVC 和 PendSV"></a>SVC 和 PendSV</h1><p>SVC（系统服务调用，亦简称系统调用）和 <code>PendSV</code>（<code>Pended System Call</code>，可悬起系统调用），它们多用于在操作系统之上的软件开发中。<code>SVC</code> 用于产生系统函数的调用请求。例如，操作系统不让用户程序直接访问硬件，而是通过提供一些系统服务函数，用户程序使用 SVC 发出对系统服务函数的呼叫请求，以这种方法调用它们来间接访问硬件。因此，当用户程序想要控制特定的硬件时，它就会产生一个 <code>SVC</code> 异常，然后操作系统提供的 <code>SVC</code> 异常服务例程得到执行，它再调用相关的操作系统函数，后者完成用户程序请求的服务。</p><p>另一个相关的异常是<code>PendSV</code>（可悬起的系统调用），它和 <code>SVC</code> 协同使用。一方面，<code>SVC</code>异常是必须立即得到响应的（若因优先级不比当前正处理的高，或是其它原因使之无法立即响应，将上访成硬 fault——译者注），应用程序执行 <code>SVC</code> 时都是希望所需的请求立即得到响应。另一方面，PendSV 则不同，它是可以像普通的中断一样被悬起的（不像 <code>SVC</code> 那样会上访）。OS 可以利用它“缓期执行”一个异常——直到其它重要的任务完成后才执行动作。悬起 <code>PendSV</code> 的方法是：手工往 <code>NVIC</code> 的<code>PendSV</code> 悬起寄存器中写 1。悬起后，如果优先级不够高，则将缓期等待执行。</p><p>如果一个发生的异常不能被即刻响应，就称它被“悬起”(pending)。不过，少数 fault异常是不允许被悬起的。一个异常被悬起的原因，可能是系统当前正在执行一个更高优先级异常的服务例程，或者因相关掩蔽位的设置导致该异常被除能。对于每个异常源，在被悬起的情况下，都会有一个对应的“悬起状态寄存器”保存其异常请求，直到该异常能够执行为止，这与传统的 ARM 是完全不同的。在以前，是由产生中断的设备保持住请求信号。现在NVIC 的悬起状态寄存器的出现解决了这个问题，即使后来设备已经释放了请求信号，曾经的中断请求也不会错失。</p><h1 id="系统任务切换的工程分析"><a href="#系统任务切换的工程分析" class="headerlink" title="系统任务切换的工程分析"></a>系统任务切换的工程分析</h1><p>在系统中正常执行的任务（假设没有外部中断<code>IRQ</code>），用<code>Systick</code>直接做上下文切换是完全没有问题的，如图：</p><p><img src="http://jiejie01.top/switch.png" alt="switch"></p><p>但是问题是几乎很少嵌入式的设备会不用其丰富的中断响应，所以，直接用systick做系统的上下文切换那是不实际的，这存在很大的风险，因为假设<code>systick</code>打断了一个中断（<code>IRQ</code>），立即做出上下文切换的话，则触犯用法 <code>fault</code>异常，除了重启你没有其他办法了，这样子做出来的产品就是垃圾！！用我老板的话说就是写的什么狗屎！！！如图所示：</p><p><img src="http://jiejie01.top/IRQ-switch.png" alt="IRQ-switch"></p><p>那这么说这样不行那也不行，怎么办啊？请看看前面接介绍的<code>PendSV</code>，是不是有点豁然开朗了？<code>PendSV</code> 来完美解决这个问题。<code>PendSV</code> 异常会自动延迟上下文切换的请求，直到其它的<code>ISR</code> 都完成了处理后才放行。为实现这个机制，需要把 <code>PendSV</code> 编程为最低优先级的异常。如果<code>OS</code>检测到某 <code>IRQ</code>正在活动并且被 SysTick 抢占，它将悬起一个 <code>PendSV</code> 异常，以便缓期执行上下文切换。</p><p>懂了吗？就是说，只要将<code>PendSV</code>的优先级设为最低的，systick即使是打断了IRQ，它也不会马上进行上下文切换，而是等到IRQ执行完，<code>PendSV</code> 服务例程才开始执行，并且在里面执行上下文切换。过程如图所示：</p><p><img src="http://jiejie01.top/pendsv-switch.png" alt="pendsv-switch"></p><h1 id="任务切换的源码实现"><a href="#任务切换的源码实现" class="headerlink" title="任务切换的源码实现"></a>任务切换的源码实现</h1><p>过程差不多了解了，那看看FreeRTOS中怎么实现吧！！</p><p>FreeRTOS有两种方法触发任务切换：</p><ol><li><p>一种就是<code>systick</code>触发<code>PendSV</code>异常，这是最经常使用的。</p></li><li><p>另一种是主动进行切换任务，执行系统调用，比如普通任务可以使用taskYIELD()强制任务切换，中断服务程序中使用<code>portYIELD_FROM_ISR()</code>强制任务切换。</p></li></ol><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><p>先说说第一种吧，就在<code>systick</code>中断中调用<code>xPortSysTickHandler()</code>;</p><p>下面是源码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">xPortSysTickHandler</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">vPortRaiseBASEPRI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Increment the RTOS tick. */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">xTaskIncrementTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* A context switch is required.  Context switching is performed in            the PendSV interrupt.  Pend the PendSV interrupt. */</span>            portNVIC_INT_CTRL_REG <span class="token operator">=</span> portNVIC_PENDSVSET_BIT<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">vPortClearBASEPRIFromISR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它的执行过程是这样子的，屏蔽所有中断，因为SysTick以最低的中断优先级运行，所以当这个中断执行时所有中断必须被屏蔽。vPortRaiseBASEPRI();就是屏蔽所有中断的。而且并不需要保存本次中断的值，因为systick的中断优先级是已知的，执行完直接恢复所有中断即可。</p><p>在<code>xTaskIncrementTick()</code>中会对<code>tick</code>的计数值进行自加，然后检查有没有处于就绪态的最优先级任务，如果有，则返回非零值，然后表示需要进行任务切换，而并非马上进行任务切换，此处要注意，它只是向中断状态寄存器<code>bit28</code>位写入<code>1</code>，只是将<code>PendSV</code>挂起，假如没有比<code>PendSV</code>更高优先级的中断，它才会进入<code>PendSV</code>中断服务函数进行任务切换。</p><pre class="line-numbers language-js"><code class="language-js">#define portNVIC_PENDSVSET_BIT        <span class="token punctuation">(</span> 1UL <span class="token operator">&lt;</span><span class="token operator">&lt;</span> 28UL <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后解除屏蔽所有中断。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">vPortClearBASEPRIFromISR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p>另一种方法是主动进行任务切换，不管是使用taskYIELD()还是portYIELD_FROM_ISR()，最终都会执行下面的代码：</p><pre class="line-numbers language-js"><code class="language-js">#define <span class="token function">portYIELD</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                                                \<span class="token punctuation">{</span>                                                                                \    <span class="token comment" spellcheck="true">/* Set a PendSV to request a context switch. */</span>                             \    portNVIC_INT_CTRL_REG <span class="token operator">=</span> portNVIC_PENDSVSET_BIT<span class="token punctuation">;</span>                             \                                                                           <span class="token function">__dsb</span><span class="token punctuation">(</span> portSY_FULL_READ_WRITE <span class="token punctuation">)</span><span class="token punctuation">;</span>                                            \    <span class="token function">__isb</span><span class="token punctuation">(</span> portSY_FULL_READ_WRITE <span class="token punctuation">)</span><span class="token punctuation">;</span>                                            \<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这<code>portYIELD()</code>其实是一个宏定义来的。同样是向中断状态寄存器<code>bit28位写入1</code>，将<code>PendSV</code>挂起，然后等待任务的切换。</p><p>具体的任务切换源码</p><p>一直在说怎么进行任务切换的，好像还没看到任务切换的源码啊，哎，下面来看看任务切换的真面目！！</p><pre class="line-numbers language-js"><code class="language-js">__asm <span class="token keyword">void</span> <span class="token function">xPortPendSVHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    extern uxCriticalNesting<span class="token punctuation">;</span>    extern pxCurrentTCB<span class="token punctuation">;</span>    extern vTaskSwitchContext<span class="token punctuation">;</span>    PRESERVE8    mrs r0<span class="token punctuation">,</span> psp    isb    ldr r3<span class="token punctuation">,</span> <span class="token operator">=</span>pxCurrentTCB       <span class="token comment" spellcheck="true">/* Get the location of the current TCB. */</span>    ldr r2<span class="token punctuation">,</span> <span class="token punctuation">[</span>r3<span class="token punctuation">]</span>    stmdb r0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>r4<span class="token operator">-</span>r11<span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">/* Save the remaining registers. */</span>    str r0<span class="token punctuation">,</span> <span class="token punctuation">[</span>r2<span class="token punctuation">]</span>                <span class="token comment" spellcheck="true">/* Save the new top of stack into the first member of the TCB. */</span>    stmdb sp<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>r3<span class="token punctuation">,</span> r14<span class="token punctuation">}</span>    mov r0<span class="token punctuation">,</span> #configMAX_SYSCALL_INTERRUPT_PRIORITY    msr basepri<span class="token punctuation">,</span> r0    dsb    isb    bl vTaskSwitchContext    mov r0<span class="token punctuation">,</span> #<span class="token number">0</span>    msr basepri<span class="token punctuation">,</span> r0    ldmia sp<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>r3<span class="token punctuation">,</span> r14<span class="token punctuation">}</span>    ldr r1<span class="token punctuation">,</span> <span class="token punctuation">[</span>r3<span class="token punctuation">]</span>    ldr r0<span class="token punctuation">,</span> <span class="token punctuation">[</span>r1<span class="token punctuation">]</span>                <span class="token comment" spellcheck="true">/* The first item in pxCurrentTCB is the task top of stack. */</span>    ldmia r0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>r4<span class="token operator">-</span>r11<span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">/* Pop the registers and the critical nesting count. */</span>    msr psp<span class="token punctuation">,</span> r0    isb    bx r14    nop<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不是我不想看，是我看到汇编就头大啊，这几天我也在看源码，实在是头大。</p><p>找到核心的函数看看就好啦，不管那么多，有兴趣的可以研究一下中断代码，有不懂的也很欢迎你们来问我，一起研究研究，也是不错的选择。</p><p>下面是看重点的地方了：</p><pre class="line-numbers language-js"><code class="language-js">mov r0<span class="token punctuation">,</span>             #configMAX_SYSCALL_INTERRUPT_PRIORITYmsr basepri<span class="token punctuation">,</span> r0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两句代码是关闭中断的。关中断就得干活了，嘿嘿嘿~</p><pre class="line-numbers language-js"><code class="language-js">bl vTaskSwitchContext<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>BL是跳转指令嘛，这个我还是有点懂的。</p><p>调用函数<code>vTaskSwitchContext()</code>,寻找新的任务运行,通过使变量<code>pxCurrentTCB</code>指向新的任务来实现任务切换,然后就是打开中断，退出去了。</p><p>寻找下一个要运行任务</p><p>是不是感觉没什么大不了的样子，如果你是这样子觉得的，可能还没学到家，赶紧去看看<code>FreeRTOS</code>的源码，在<code>config.h</code>配置文件中是不是有一个叫做硬件查找下一个运行的任务呢？<code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code>，这个在<code>FreeRTOS</code>中叫做特殊方法，其实也是硬件查找啦，但是并不是每种单片机都支持的，如果是不支持的话，只能选择软件查找的方法了，就是所谓的通用方法。通用方法我就不多说了，因为我用的是<code>STM32</code>，他是<code>支持硬件方法</code>的，这样子效率更高，所以我也没必要去研究他的软件方法，假如有兴趣的小伙伴可以研读一下源码，有不懂的可以向我提问，源码如下：</p><pre class="line-numbers language-js"><code class="language-js">#define <span class="token function">taskSELECT_HIGHEST_PRIORITY_TASK</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                                            \    <span class="token punctuation">{</span>                                                                                                   \    UBaseType_t uxTopPriority <span class="token operator">=</span> uxTopReadyPriority<span class="token punctuation">;</span>                                                     \                                                                                                        \        <span class="token comment" spellcheck="true">/* Find the highest priority queue that contains ready tasks. */</span>                                \        <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token function">listLIST_IS_EMPTY</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxReadyTasksLists<span class="token punctuation">[</span> uxTopPriority <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span>                           \        <span class="token punctuation">{</span>                                                                                               \            <span class="token function">configASSERT</span><span class="token punctuation">(</span> uxTopPriority <span class="token punctuation">)</span><span class="token punctuation">;</span>                                                              \            <span class="token operator">--</span>uxTopPriority<span class="token punctuation">;</span>                                                                            \        <span class="token punctuation">}</span>                                                                                               \                                                                                                        \        <span class="token comment" spellcheck="true">/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of                        \        the same priority get an equal share of the processor time. */</span>                                  \        <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span> pxCurrentTCB<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxReadyTasksLists<span class="token punctuation">[</span> uxTopPriority <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>           \        uxTopReadyPriority <span class="token operator">=</span> uxTopPriority<span class="token punctuation">;</span>                                                             \    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* taskSELECT_HIGHEST_PRIORITY_TASK */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而硬件的方法源码则在下面：</p><pre class="line-numbers language-js"><code class="language-js">    #define <span class="token function">taskSELECT_HIGHEST_PRIORITY_TASK</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                                      \    <span class="token punctuation">{</span>                                                                                               \        UBaseType_t uxTopPriority<span class="token punctuation">;</span>                                                                  \                                                                                                    \        <span class="token comment" spellcheck="true">/* Find the highest priority list that contains ready tasks. */</span>                             \        <span class="token function">portGET_HIGHEST_PRIORITY</span><span class="token punctuation">(</span> uxTopPriority<span class="token punctuation">,</span> uxTopReadyPriority <span class="token punctuation">)</span><span class="token punctuation">;</span>                              \        <span class="token function">configASSERT</span><span class="token punctuation">(</span> <span class="token function">listCURRENT_LIST_LENGTH</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxReadyTasksLists<span class="token punctuation">[</span> uxTopPriority <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>     \        <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span> pxCurrentTCB<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxReadyTasksLists<span class="token punctuation">[</span> uxTopPriority <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>       \    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* taskSELECT_HIGHEST_PRIORITY_TASK() */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其方法是利用硬件提供的计算前导零指令CLZ，具体宏定义为：</p><pre class="line-numbers language-js"><code class="language-js">#define <span class="token function">portGET_HIGHEST_PRIORITY</span><span class="token punctuation">(</span> uxTopPriority<span class="token punctuation">,</span> uxReadyPriorities <span class="token punctuation">)</span> uxTopPriority <span class="token operator">=</span> <span class="token punctuation">(</span> 31UL <span class="token operator">-</span> <span class="token punctuation">(</span> uint32_t <span class="token punctuation">)</span> <span class="token function">__clz</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> uxReadyPriorities <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>静态变量<code>uxTopReadyPriority</code>包含了处于就绪态任务的最高优先级的信息，因为<code>FreeRTOS</code>运行的永远是处于最高优先级的运行态，而下个处于最高优先级的就绪态则必定会在下次任务切换的时候运行，<code>uxTopReadyPriority</code>使用每一位来表示任务是否处于就绪态，比如变量<code>uxTopReadyPriority</code>的<code>bit0为1</code>，则表示存在优先级为0的任务处于就绪态，<code>bit6为1</code>则表示存在优先级为6的任务处于就绪态。并且，由于<code>bit0</code>的优先级高于<code>bit6</code>，那么下个任务就是bit0的任务运行了（数组越低优先级越高）。由于32位整形数最多只有<code>32</code>位，因此使用这种特殊方法限定最大可用优先级数目为<code>32</code>，即优先级<code>0~31</code>。得到了下个处于最高优先级就绪态任务了，就调用<code>listGET_OWNER_OF_NEXT_ENTRY</code>来获取下一个任务的列表项，然后将该列表项的任务控制块TCB赋值给<code>pxCurrentTCB</code>，那么我们就得到下一个要运行的任务了。</p><p>至此，任务切换已经完成。</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从单片机到操作系统-3</title>
      <link href="/freertos-3/"/>
      <url>/freertos-3/</url>
      
        <content type="html"><![CDATA[<h1 id="FreeRTOS列表-amp-列表项的源码解读"><a href="#FreeRTOS列表-amp-列表项的源码解读" class="headerlink" title="FreeRTOS列表&amp;列表项的源码解读"></a>FreeRTOS列表&amp;列表项的源码解读</h1><p>第一次看列表与列表项的时候，感觉很像是链表，虽然我自己的链表也不太会，但是就是感觉很像。</p><p>在<code>FreeRTOS</code>中，列表与列表项使用得非常多，是<code>FreeRTOS</code>的一个数据结构，学习过数据结构的同学都知道，数据结构能使我们处理数据更加方便快速，能快速找到数据，在<code>FreeRTOS</code>中，这种列表与列表项更是必不可少的，能让我们的系统跑起来更加流畅迅速。</p><p>言归正传，<code>FreeRTOS</code>中使用了大量的列表<code>（List）</code>与列表项<code>（Listitem）</code>，在<code>FreeRTOS</code>调度器中，就是用到这些来跟着任务，了解任务的状态，处于挂起、阻塞态、还是就绪态亦或者是运行态。这些信息都会在各自任务的列表中得到。</p><p>看任务控制块<code>（tskTaskControlBlock）</code>中的两个列表项：</p><pre class="line-numbers language-js"><code class="language-js">ListItem_t xStateListItem<span class="token punctuation">;</span> <span class="token regex">/ * &lt;任务的状态列表项目引用的列表表示该任务的状态（就绪，已阻止，暂停）。*/</span>ListItem_t xEventListItem<span class="token punctuation">;</span> <span class="token regex">/ * &lt;用于从事件列表中引用任务。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个是状态的列表项，一个是事件列表项。他们在创建任务就会被初始化，列表项的初始化是根据实际需要来初始化的，下面会说。</p><h1 id="FreeRTOS列表-amp-列表项的结构体"><a href="#FreeRTOS列表-amp-列表项的结构体" class="headerlink" title="FreeRTOS列表&amp;列表项的结构体"></a>FreeRTOS列表&amp;列表项的结构体</h1><p>既然知道列表与列表项的重要性，那么我们来解读FreeRTOS中的list.c与list.h的源码吧。从头文件lsit.h开始，看到定义了一些结构体：</p><pre class="line-numbers language-js"><code class="language-js">struct xLIST_ITEM<span class="token punctuation">{</span>listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="token regex">/ * &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。* /</span>configLIST_VOLATILE TickType_t xItemValue<span class="token punctuation">;</span> <span class="token regex">/ * &lt;正在列出的值。在大多数情况下，这用于按降序对列表进行排序。 * /</span>struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxNext<span class="token punctuation">;</span> <span class="token regex">/ * &lt;指向列表中下一个ListItem_t的指针。 * /</span>struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxPrevious<span class="token punctuation">;</span> <span class="token regex">/ * &lt;指向列表中前一个ListItem_t的指针。 * /</span><span class="token keyword">void</span> <span class="token operator">*</span> pvOwner<span class="token punctuation">;</span> <span class="token regex">/ * &lt;指向包含列表项目的对象（通常是TCB）的指针。因此，包含列表项目的对象与列表项目本身之间存在双向链接。 * /</span><span class="token keyword">void</span> <span class="token operator">*</span> configLIST_VOLATILE pvContainer<span class="token punctuation">;</span> <span class="token regex">/ * &lt;指向此列表项目所在列表的指针（如果有）。 * /</span>listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="token regex">/ * &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。* /</span><span class="token punctuation">}</span><span class="token punctuation">;</span>typedef struct xLIST_ITEM ListItem_t<span class="token punctuation">;</span> <span class="token regex">/ *由于某种原因，lint希望将其作为两个单独的定义。 * /</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="列表项结构体的一些注意的地方："><a href="#列表项结构体的一些注意的地方：" class="headerlink" title="列表项结构体的一些注意的地方："></a>列表项结构体的一些注意的地方：</h2><p><code>xItemValue</code> 用于列表项的排序，类似1—2—3—4</p><p><code>pxNext</code> 指向下一个列表项的指针</p><p><code>pxPrevious</code> 指向上（前）一个列表项的指针</p><p>这两个指针实现了类似双向链表的功能</p><p><code>pvOwner</code> 指向包含列表项目的对象（<code>通常是任务控制块TCB</code>）的指针。因此，包含列表项目的对象与列表项目本身之间存在双向链接。</p><p><code>pvContainer</code> 记录了该列表项属于哪个列表，说白点就是这个儿子是谁生的。。。</p><p>同时定义了一个MINI的列表项的结构体，MINI列表项是删减版的列表项，因为很多时候不需要完全版的列表项。就不用浪费那么多内存空间了，这或许就是FreeRTOS是轻量级操作系统的原因吧，能省一点是一点。MINI列表项：</p><pre class="line-numbers language-js"><code class="language-js">struct xMINI_LIST_ITEM<span class="token punctuation">{</span>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE           <span class="token comment" spellcheck="true">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span>    configLIST_VOLATILE TickType_t xItemValue<span class="token punctuation">;</span>    struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxNext<span class="token punctuation">;</span>    struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxPrevious<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>typedef struct xMINI_LIST_ITEM MiniListItem_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再定义了一个列表的结构体，可能看到这里，一些同学已经蒙了，列表与列表项是啥关系啊，按照杰杰的理解，是类似父子关系的，一个列表中，包含多个列表项，就像一个父亲，生了好多孩子，而列表就是父亲，列表项就是孩子。</p><pre class="line-numbers language-js"><code class="language-js">typedef struct xLIST<span class="token punctuation">{</span>listFIRST_LIST_INTEGRITY_CHECK_VALUE <span class="token regex">/ * &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。* /</span>configLIST_VOLATILE UBaseType_t uxNumberOfItems<span class="token punctuation">;</span>ListItem_t <span class="token operator">*</span> configLIST_VOLATILE pxIndex<span class="token punctuation">;</span> <span class="token regex">/ * &lt;用于遍历列表。 指向由listGET_OWNER_OF_NEXT_ENTRY（）调用返回的后一个列表项。*/</span>MiniListItem_t xListEnd<span class="token punctuation">;</span> <span class="token regex">/ * &lt;List item包含最大可能的项目值，这意味着它始终在列表的末尾，因此用作标记。*/</span>listSECOND_LIST_INTEGRITY_CHECK_VALUE <span class="token regex">/ * &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。* /</span><span class="token punctuation">}</span> List_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列表的结构体中值得注意的是：<br><code>uxNumberOfItems</code> 是用来记录列表中列表项的数量的，就是记录父亲有多少个儿子，当然女儿也行~。</p><p><code>pxIndex</code> 是索引编号，用来遍历列表的，调用宏<code>listGET_OWNER_OF_NEXT_ENTRY（）</code>之后索引就会指向返回当前列表项的下一个列表项。</p><p><code>xListEnd</code> 指向的是最后一个列表项，并且这个列表项是<code>MiniListItem</code>属性的，是一个迷你列表项。</p><h1 id="列表的初始化"><a href="#列表的初始化" class="headerlink" title="列表的初始化"></a>列表的初始化</h1><p>  函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInitialise</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList <span class="token punctuation">)</span><span class="token punctuation">{</span>    pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/*lint The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>    pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>xItemValue <span class="token operator">=</span> portMAX_DELAY<span class="token punctuation">;</span>    pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>pxNext <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/*lint The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>    pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>pxPrevious <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*lint The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>    pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token operator">=</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> 0U<span class="token punctuation">;</span>    <span class="token function">listSET_LIST_INTEGRITY_CHECK_1_VALUE</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listSET_LIST_INTEGRITY_CHECK_2_VALUE</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将列表的索引指向列表中的<code>xListEnd</code>，也就是末尾的列表项<code>（迷你列表项）</code></p><p>列表项的<code>xItemValue</code>数值为<code>portMAX_DELAY</code>，也就是<code>0xffffffffUL</code>，如果在16位处理器中则为<code>0xffff</code>。</p><p>列表项的pxNext与pxPrevious这两个指针都指向自己本身<code>xListEnd</code>。</p><p>初始化完成的时候列表项的数目为<code>0</code>个。因为还没添加列表项嘛~。</p><p><img src="http://jiejie01.top/freertos4.png" alt="freertos4"></p><h1 id="列表项的初始化"><a href="#列表项的初始化" class="headerlink" title="列表项的初始化"></a>列表项的初始化</h1><p> 函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxItem <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* Make sure the list item is not recorded as being on a list. */</span>    pxItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> NULL<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Write known values into the list item if    configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span>    <span class="token function">listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE</span><span class="token punctuation">(</span> pxItem <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE</span><span class="token punctuation">(</span> pxItem <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只需要让列表项的pvContainer指针指向NULL即可，这样子就使得列表项不属于任何一个列表，因为列表项的初始化是要根据实际的情况来进行初始化的。</p><p>例如任务创建时用到的一些列表项初始化：</p><pre class="line-numbers language-js"><code class="language-js">pxNewTCB<span class="token operator">-</span><span class="token operator">></span>pcTaskName<span class="token punctuation">[</span> configMAX_TASK_NAME_LEN <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>pxNewTCB<span class="token operator">-</span><span class="token operator">></span>uxPriority <span class="token operator">=</span> uxPriority<span class="token punctuation">;</span>pxNewTCB<span class="token operator">-</span><span class="token operator">></span>uxBasePriority <span class="token operator">=</span> uxPriority<span class="token punctuation">;</span>pxNewTCB<span class="token operator">-</span><span class="token operator">></span>uxMutexesHeld <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTCB<span class="token operator">-</span><span class="token operator">></span>xStateListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTCB<span class="token operator">-</span><span class="token operator">></span>xEventListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>又或者是在定时器相关的初始化中：</p><pre class="line-numbers language-js"><code class="language-js">pxNewTimer<span class="token operator">-</span><span class="token operator">></span>pcTimerName <span class="token operator">=</span> pcTimerName<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>xTimerPeriodInTicks <span class="token operator">=</span> xTimerPeriodInTicks<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>uxAutoReload <span class="token operator">=</span> uxAutoReload<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>pvTimerID <span class="token operator">=</span> pvTimerID<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>pxCallbackFunction <span class="token operator">=</span> pxCallbackFunction<span class="token punctuation">;</span><span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTimer<span class="token operator">-</span><span class="token operator">></span>xTimerListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="列表项的末尾插入"><a href="#列表项的末尾插入" class="headerlink" title="列表项的末尾插入"></a>列表项的末尾插入</h1><p>  函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInsertEnd</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList<span class="token punctuation">,</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">{</span>    ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxIndex <span class="token operator">=</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_INTEGRITY</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_ITEM_INTEGRITY</span><span class="token punctuation">(</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token operator">*</span><span class="token operator">/</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIndex<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  1 </span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  2</span>    <span class="token comment" spellcheck="true">/* Only used during decision coverage testing. */</span>    <span class="token function">mtCOVERAGE_TEST_DELAY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  3 </span>    pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//  4</span>    <span class="token comment" spellcheck="true">/* Remember which list the item is in. */</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pxList<span class="token punctuation">;</span>    <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传入的参数：</p><p><code>pxList</code>：列表项要插入的列表。</p><p><code>pxNewListItem</code>：要插入的列表项是什么。</p><p>从末尾插入，那就要先知道哪里是头咯，我们在列表中的成员<code>pxIndex</code>就是用来遍历列表项的啊，那它指向的地方就是列表项的头，那么既然FreeRTOS中的列表很像数据结构中的双向链表，那么，我们可以把它看成一个环，是首尾相连的，那么函数中说的末尾，就是列表项头的前一个，很显然其结构图应该是下图这样子的（初始化结束后<code>pxIndex</code>指向了<code>xListEnd</code>）：</p><p><img src="http://jiejie01.top/freertos5.png" alt="freertos5"></p><p>为什么是这样子的呢，一句句代码来解释：</p><p>一开始：</p><pre class="line-numbers language-js"><code class="language-js">ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxIndex <span class="token operator">=</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存了一开始的索引列表项（<code>xListEnd</code>）的指向。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIndex<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//  1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新列表项的下一个指向为索引列表项，也就是绿色的箭头。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>刚开始我们初始化完成的时候<code>pxIndex-&gt;pxPrevious</code>的指向为自己xListEnd，那么<code>xNewListItem-&gt;pxPrevious</code>的指向为xListEnd。如2紫色的箭头。</p><pre class="line-numbers language-js"><code class="language-js">pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>索引列表项（xListEnd）的上一个列表项还是自己，那么自己的下一个列表项指向就是指向了<code>pxNewListItem</code>。</p><pre class="line-numbers language-js"><code class="language-js">pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//  4</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这句就很容易理解啦。如图的4橙色的箭头。</p><p>插入完毕的时候标记一下新的列表项插入了哪个列表，并且将<code>uxNumberOfItems</code>进行加一，以表示多了一个列表项。</p><p>为什么源码要这样子写呢？因为这只是两个列表项，一个列表含有多个列表项，那么这段代码的通用性就很强了。无论原本列表中有多少个列表项，也无论<code>pxIndex</code>指向哪个列表项！</p><p><img src="http://jiejie01.top/freertos6.png" alt="freertos6"></p><p><img src="http://jiejie01.top/freertos7.png" alt="freertos7"></p><p>看看是不是按照源码中那样插入呢？</p><h1 id="列表项的插入"><a href="#列表项的插入" class="headerlink" title="列表项的插入"></a>列表项的插入</h1><p> 源码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInsert</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList<span class="token punctuation">,</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">{</span>ListItem_t <span class="token operator">*</span>pxIterator<span class="token punctuation">;</span><span class="token keyword">const</span> TickType_t xValueOfInsertion <span class="token operator">=</span> pxNewListItem<span class="token operator">-</span><span class="token operator">></span>xItemValue<span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_INTEGRITY</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_ITEM_INTEGRITY</span><span class="token punctuation">(</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span> xValueOfInsertion <span class="token operator">==</span> portMAX_DELAY <span class="token punctuation">)</span>   <span class="token punctuation">{</span>        pxIterator <span class="token operator">=</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>pxPrevious<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> pxIterator <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>xItemValue <span class="token operator">&lt;=</span> xValueOfInsertion<span class="token punctuation">;</span> pxIterator <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* There is nothing to do here, just iterating to the wanted            insertion position. */</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIterator<span class="token punctuation">;</span>    pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Remember which list the item is in.  This allows fast removal of the    item later. */</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pxList<span class="token punctuation">;</span>    <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传入的参数：</p><p><code>pxList</code>：列表项要插入的列表。<br><code>pxNewListItem</code>：要插入的列表项是什么。</p><p>pxList决定了插入哪个列表，<code>pxNewListItem</code>中的<code>xItemValue</code>值决定了列表项插入列表的位置。</p><pre class="line-numbers language-js"><code class="language-js">ListItem_t <span class="token operator">*</span>pxIterator<span class="token punctuation">;</span>  <span class="token keyword">const</span> TickType_t xValueOfInsertion <span class="token operator">=</span> pxNewListItem<span class="token operator">-</span><span class="token operator">></span>xItemValue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>定义一个辅助的列表项pxIterator，用来迭代找出插入新列表项的位置，并且保存获取要插入的列表项<code>pxNewListItem</code>的xItemValue。</p><p>如果打开了列表项完整性检查，就要用户实现<code>configASSERT()</code>，源码中有说明。</p><p>既然是要插入列表项，那么肯定是要知道列表项的位置了，如果新插入列表项的<code>xItemValue</code>是最大的话<code>（portMAX_DELAY）</code>，就直接插入列表项的末尾。否则就需要比较列表中各个列表项的<code>xItemValue</code>的大小来进行排列。然后得出新列表项插入的位置。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span> pxIterator <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>xItemValue <span class="token operator">&lt;=</span> xValueOfInsertion<span class="token punctuation">;</span> pxIterator <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面源码就是实现比较的过程。</p><p>与上面的从列表项末尾插入的源码一样，FreeRTOS的代码通用性很强，逻辑思维也很强。</p><p>如果列表中列表项的数量为0，那么插入的列表项就是在初始化列表项的后面。如下图所示：</p><p><img src="http://jiejie01.top/freertos8.png" alt="freertos8"></p><h2 id="过程分析："><a href="#过程分析：" class="headerlink" title="过程分析："></a>过程分析：</h2><p>新列表项的<code>pxNext</code>指向<code>pxIterator-&gt;pxNext</code>，也就是指向了<code>xListEnd（pxIterator）</code>。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而xListEnd（pxIterator）的pxPrevious指向则为pxNewListItem。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新列表项的<code>（pxPrevious）</code>指针指向<code>xListEnd（pxIterator）</code></p><p><code>pxIterator</code> 的 <code>pxNext</code> 指向了<code>新</code>列表项</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIterator<span class="token punctuation">;</span>pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>与从末尾插入列表项其实是一样的，前提是当前列表中列表项的数目为0。</p><p>假如列表项中已经有了元素呢，过程又是不一样的了。原来的列表是下图这样子的：</p><p><img src="http://jiejie01.top/freertos9.png" alt="freertos9"></p><p>假设插入的列表项的<code>xItemValue</code>是<code>2</code>，而原有的列表项的<code>xItemValue</code>值是<code>3</code>，那么，按照源码，我们插入的列表项是在中间了。而pxIterator则是①号列表项。</p><p>插入后的效果：</p><p><img src="http://jiejie01.top/freertos10.png" alt="freertos10"></p><p>分析一下插入的过程：</p><p>新的列表项的<code>pxNext</code>指向的是<code>pxIterator-&gt;pxNext</code>，也就是③号列表项。因为一开始pxIterator-&gt;pxNext=指向的就是③号列表项！！</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而pxNewListItem-&gt;pxNext 即③号列表项的指向上一个列表项指针（<code>pxPrevious</code>）的则指向新插入的列表项，也就是②号列表项了。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新插入列表项的指向上一个列表项的指针<code>pxNewListItem-&gt;pxPrevious</code>指向了辅助列表项<code>pxIterator</code>。很显然要连接起来嘛！</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIterator<span class="token punctuation">;</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同理，<code>pxIterator</code>列表项的指向下一个列表项的指针则指向新插入的列表项了<code>pxNewListItem</code>。</p><pre class="line-numbers language-js"><code class="language-js">pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而其他没改变指向的地方不需改动。（图中的两条直线做的连接线是不需要改动的）</p><p>当插入完成的时候，记录一下新插入的列表项属于哪个列表。并且让该列表下的列表项数目加一。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pxList<span class="token punctuation">;</span>         <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="删除列表项"><a href="#删除列表项" class="headerlink" title="删除列表项"></a>删除列表项</h1><pre><code>源码：</code></pre><pre class="line-numbers language-js"><code class="language-js">UBaseType_t <span class="token function">uxListRemove</span><span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxItemToRemove <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* The list item knows which list it is in.  Obtain the list from the listitem. */</span>List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList <span class="token operator">=</span> <span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token punctuation">)</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pvContainer<span class="token punctuation">;</span>    pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Only used during decision coverage testing. */</span>    <span class="token function">mtCOVERAGE_TEST_DELAY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Make sure the index is left pointing to a valid item. */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">==</span> pxItemToRemove <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> NULL<span class="token punctuation">;</span>    <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  其实删除是很简单的，不用想都知道，要删除列表项，那肯定要知道该列表项是属于哪个列表吧，pvContainer就是记录列表项是属于哪个列表的。</p><p>  删除就是把列表中的列表项从列表中去掉，其本质其实就是把他们的连接关系删除掉，然后让删除的列表项的前后两个列表连接起来就行了，假如是只有一个列表项，那么删除之后，列表就回到了初始化的状态了。</p><pre class="line-numbers language-js"><code class="language-js">pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两句代码就实现了将删除列表项的前后两个列表项连接起来。</p><p>按照上面的讲解可以理解这两句简单的代码啦。</p><p>假如删除的列表项是当前索引的列表项，那么在删除之后，列表中的pxIndex就要指向删除列表项的上一个列表项了。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">==</span> pxItemToRemove <span class="token punctuation">)</span>  <span class="token punctuation">{</span>     pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当然还要把当前删除的列表项的<code>pvContainer</code>指向<code>NULL</code>，让它不属于任何一个列表，因为，删除的本质是删除的仅仅是列表项的连接关系，其内存是没有释放掉的，假如是动态内存分配的话。</p><p>并且要把当前列表中列表项的数目返回一下。</p><p>至此，列表的源码基本讲解完毕。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>大家还可以了解一下遍历列表的宏，它在list.h文件中：</p><pre class="line-numbers language-js"><code class="language-js">define <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span> pxTCB<span class="token punctuation">,</span> pxList <span class="token punctuation">)</span>                                        \<span class="token punctuation">{</span>                                                                                            \List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxConstList <span class="token operator">=</span> <span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>                                                    \    <span class="token comment" spellcheck="true">/* Increment the index to the next item and return the item, ensuring */</span>                \    <span class="token comment" spellcheck="true">/* we don't return the marker used at the end of the list.  */</span>                          \    <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>                            \    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">==</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span> <span class="token punctuation">)</span>  \    <span class="token punctuation">{</span>                                                                                       \         <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>                        \    <span class="token punctuation">}</span>                                                                                       \    <span class="token punctuation">(</span> pxTCB <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token operator">-</span><span class="token operator">></span>pvOwner<span class="token punctuation">;</span>                                          \<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个宏，用于列表的遍历，返回的是列表中列表项的<code>pxOwner</code>成员，每次调用这个宏（函数）的时候，其pxIndex索引会指向当前返回列表项的下一个列表项。</p><p><img src="http://jiejie01.top/%E6%AC%A2%E8%BF%8E%E5%85%B3%E6%B3%A8%E6%88%91%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="欢迎关注我公众号"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从单片机到操作系统-2</title>
      <link href="/freertos-2/"/>
      <url>/freertos-2/</url>
      
        <content type="html"><![CDATA[<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>开始今天的内容之前，先补充一下上篇文章<a href="https://jiejietop.gitee.io/freertos-1/" target="_blank" rel="noopener">从单片机到操作系统-1</a>的一点点遗漏的知识点。</p><pre class="line-numbers language-js"><code class="language-js"> BaseType_t <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>       TaskFunction_t pvTaskCode<span class="token punctuation">,</span>                               <span class="token keyword">const</span> char <span class="token operator">*</span> <span class="token keyword">const</span> pcName<span class="token punctuation">,</span>                               uint16_t usStackDepth<span class="token punctuation">,</span>                               <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">,</span>                               UBaseType_t uxPriority<span class="token punctuation">,</span>                               TaskHandle_t <span class="token operator">*</span>pvCreatedTask                           <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 创建任务中的堆栈大小问题，在task.h中有这样子的描述：</p><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">/*** @param usStackDepth The size of the task stack specified as the number of variables the stack * can hold - not the number of bytes.  For example, if the stack is 16 bits wide and  * usStackDepth is defined as 100, 200 byteswill be allocated for stack storage.*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当任务创建时，内核会分为每个任务分配属于任务自己的唯一堆栈。usStackDepth 值用于告诉内核为它应该分配多大的栈空间。</p><p>这个值指定的是栈空间可以保存多少个字(word) ，而不是多少个字节(byte)。</p><p>文档也有说明，如果是16位宽度的话，假如usStackDepth = 100；那么就是200个字节（byte）。</p><p>当然，我用的是stm32，32位宽度的， usStackDepth=100；那么就是400个字节（byte）。</p><p>好啦，补充完毕。下面正式开始我们今天的主题。</p><hr><p>我自己学的是应用层的东西，很多底层的东西我也不懂，水平有限，出错了还请多多包涵。</p><p>其实我自己写文章的时候也去跟着火哥的书看着底层的东西啦，但是本身自己也是不懂，不敢乱写。所以，这个《从单片机到操作系统》系列的文章，我会讲一点底层，更多的是应用层，主要是用的方面。</p><p>按照一般的写代码的习惯，在main函数里面各类初始化完毕了，并且创建任务成功了，那么，可以开启任务调度了。</p><pre class="line-numbers language-js"><code class="language-js">int <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">NVIC_PriorityGroupConfig</span><span class="token punctuation">(</span>NVIC_PriorityGroup_4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置系统中断优先级分组4    </span>    <span class="token function">Delay_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//延时函数初始化     </span>    <span class="token function">Uart_Init</span><span class="token punctuation">(</span><span class="token number">115200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//初始化串口</span>    <span class="token function">LED_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//初始化LED</span>    <span class="token function">KEY_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//创建开始任务</span>    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t <span class="token punctuation">)</span>start_task<span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">//任务函数</span>                <span class="token punctuation">(</span><span class="token keyword">const</span> char<span class="token operator">*</span>    <span class="token punctuation">)</span><span class="token string">"start_task"</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">//任务名称</span>                <span class="token punctuation">(</span>uint16_t       <span class="token punctuation">)</span>START_STK_SIZE<span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//任务堆栈大小</span>                <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>          <span class="token punctuation">)</span>NULL<span class="token punctuation">,</span>                  <span class="token comment" spellcheck="true">//传递给任务函数的参数</span>                <span class="token punctuation">(</span>UBaseType_t    <span class="token punctuation">)</span>START_TASK_PRIO<span class="token punctuation">,</span>       <span class="token comment" spellcheck="true">//任务优先级</span>                <span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span>  <span class="token punctuation">)</span><span class="token operator">&amp;</span>StartTask_Handler<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//任务句柄              </span>    <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//开启任务调度</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>来大概看看分析一下创建任务的过程，虽然说会用就行，但是也是要知道了解一下的。</p><p>注意：下面说的创建任务均为xTaskCreate（动态创建）而非静态创建。</p><pre class="line-numbers language-js"><code class="language-js">pxStack <span class="token operator">=</span> <span class="token punctuation">(</span> StackType_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token function">pvPortMalloc</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span> size_t <span class="token punctuation">)</span> usStackDepth <span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">sizeof</span><span class="token punctuation">(</span> StackType_t <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>             <span class="token keyword">if</span><span class="token punctuation">(</span> pxStack <span class="token operator">!=</span> NULL <span class="token punctuation">)</span>             <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">/* Allocate space for the TCB. */</span>                 pxNewTCB <span class="token operator">=</span> <span class="token punctuation">(</span> TCB_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token function">pvPortMalloc</span><span class="token punctuation">(</span> <span class="token function">sizeof</span><span class="token punctuation">(</span> TCB_t <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">/*lint !e961 MISRA exception as the casts are only redundant for some paths. */</span>                 <span class="token keyword">if</span><span class="token punctuation">(</span> pxNewTCB <span class="token operator">!=</span> NULL <span class="token punctuation">)</span>                 <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">/* Store the stack location in the TCB. */</span>                    pxNewTCB<span class="token operator">-</span><span class="token operator">></span>pxStack <span class="token operator">=</span> pxStack<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">/* The stack cannot be used as the TCB was not created.  Free                    it again. */</span>                    <span class="token function">vPortFree</span><span class="token punctuation">(</span> pxStack <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                pxNewTCB <span class="token operator">=</span> NULL<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先是利用<code>pvPortMalloc</code>给任务的堆栈分配空间，<code>if( pxStack != NULL )</code>如果内存申请成功，就接着给任务控制块申请内存。<code>pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );</code>同样是使用<code>pvPortMalloc();</code>如果任务控制块内存申请失败则释放 之前已经申请成功的任务堆栈<code>的内存vPortFree( pxStack );</code></p><p>然后就初始化任务相关的东西，并且将新初始化的任务控制块添加到列表中<code>prvAddNewTaskToReadyList( pxNewTCB );</code></p><p>  最后返回任务的状态，如果是成功了就是<code>pdPASS</code>，假如失败了就是返回<code>errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">prvInitialiseNewTask</span><span class="token punctuation">(</span>    pxTaskCode<span class="token punctuation">,</span>                          pcName<span class="token punctuation">,</span>                          <span class="token punctuation">(</span> uint32_t <span class="token punctuation">)</span> usStackDepth<span class="token punctuation">,</span>                         pvParameters<span class="token punctuation">,</span>                         uxPriority<span class="token punctuation">,</span>                          pxCreatedTask<span class="token punctuation">,</span>                         pxNewTCB<span class="token punctuation">,</span>                          NULL <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">prvAddNewTaskToReadyList</span><span class="token punctuation">(</span> pxNewTCB <span class="token punctuation">)</span><span class="token punctuation">;</span>            xReturn <span class="token operator">=</span> pdPASS<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            xReturn <span class="token operator">=</span> errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> xReturn<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 相关宏定义</span>#define pdPASS            <span class="token punctuation">(</span> pdTRUE <span class="token punctuation">)</span>#define pdTRUE            <span class="token punctuation">(</span> <span class="token punctuation">(</span> BaseType_t <span class="token punctuation">)</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token comment" spellcheck="true">/* FreeRTOS error definitions. */</span>#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY    <span class="token punctuation">(</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体的<code>static void prvInitialiseNewTask()</code>实现请参考<code>FreeRTOS</code>的<code>tasks.c</code>文件的<code>767</code>行代码。具体的<code>static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )</code>实现请参考<code>FreeRTOS</code>的<code>tasks.c</code>文件的<code>963</code>行代码。</p><p>因为这些是<code>tasks.c</code>中的<code>静态的函数</code>，仅供xTaskCreate创建任务内部调用的，我们无需理会这些函数的实现过程，当然如果需要请自行了解。</p><p>创建完任务就开启任务调度了：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//开启任务调度</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在任务调度里面，会创建一个空闲任务（我们将的都是动态创建任务，静态创建其实一样的）</p><pre class="line-numbers language-js"><code class="language-js">xReturn <span class="token operator">=</span> <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>    prvIdleTask<span class="token punctuation">,</span>                          <span class="token string">"IDLE"</span><span class="token punctuation">,</span> configMINIMAL_STACK_SIZE<span class="token punctuation">,</span>                          <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> NULL<span class="token punctuation">,</span>                          <span class="token punctuation">(</span> tskIDLE_PRIORITY <span class="token operator">|</span> portPRIVILEGE_BIT <span class="token punctuation">)</span><span class="token punctuation">,</span>                          <span class="token operator">&amp;</span>xIdleTaskHandle <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */</span>    <span class="token punctuation">}</span>相关宏定义：#define tskIDLE_PRIORITY            <span class="token punctuation">(</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> 0U <span class="token punctuation">)</span>#ifndef portPRIVILEGE_BIT    #define portPRIVILEGE_BIT <span class="token punctuation">(</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> <span class="token number">0x00</span> <span class="token punctuation">)</span>#endif#define configUSE_TIMERS                        <span class="token number">1</span>                               <span class="token comment" spellcheck="true">//为1时启用软件定时器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码我们可以看出，空闲任务的优先级是tskIDLE_PRIORITY为0，也就是说空闲任务的优先级最低。当CPU没事干的时候才执行空闲任务，以待随时切换优先级更高的任务。</p><p>如果使用了软件定时器的话，我们还需要创建定时器任务，创建的函数是：</p><pre class="line-numbers language-js"><code class="language-js">#<span class="token keyword">if</span> <span class="token punctuation">(</span> configUSE_TIMERS <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span>    BaseType_t <span class="token function">xTimerCreateTimerTask</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后还要把中断关一下</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">portDISABLE_INTERRUPTS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>至于为什么关中断，也有说明：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* Interrupts are turned off here, toensure a tick does not occurbefore or during the call toxPortStartScheduler().  The stacks ofthe created tasks contain a status wordwith interrupts switched onso interrupts will automatically getre-enabled when the first taskstarts to run. */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>中断在这里被关闭，以确保不会发生滴答在调用xPortStartScheduler（）之前或期间。堆栈创建的任务包含一个打开中断的状态字因此中断将在第一个任务时自动重新启用开始运行。</p><p>那么如何打开中断呢？？？？这是个很重要的问题</p><p>别担心，我们在SVC中断服务函数里面就会打开中断的</p><p>看代码：</p><pre class="line-numbers language-js"><code class="language-js">__asm <span class="token keyword">void</span> <span class="token function">vPortSVCHandler</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>         PRESERVE8         ldr    r3<span class="token punctuation">,</span> <span class="token operator">=</span>pxCurrentTCB  <span class="token comment" spellcheck="true">/* Restore the context. */</span>         ldrr1<span class="token punctuation">,</span> <span class="token punctuation">[</span>r3<span class="token punctuation">]</span>                            <span class="token comment" spellcheck="true">/* UsepxCurrentTCBConst to get the pxCurrentTCB address. */</span>         ldrr0<span class="token punctuation">,</span> <span class="token punctuation">[</span>r1<span class="token punctuation">]</span>                            <span class="token comment" spellcheck="true">/* Thefirst item in pxCurrentTCB is the task top of stack. */</span>         ldmiar0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>r4<span class="token operator">-</span>r11<span class="token punctuation">}</span>             <span class="token comment" spellcheck="true">/* Pop theregisters that are not automatically saved on exception entry and the criticalnesting count. */</span>         msrpsp<span class="token punctuation">,</span> r0                                   <span class="token comment" spellcheck="true">/*Restore the task stack pointer. */</span>         isb         movr0<span class="token punctuation">,</span> #<span class="token number">0</span>         msr  basepri<span class="token punctuation">,</span> r0         orrr14<span class="token punctuation">,</span> #<span class="token number">0xd</span>         bxr14<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">msr  basepri<span class="token punctuation">,</span> r0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就是它把中断打开的。看不懂没所谓，我也不懂汇编，看得懂知道就好啦。</p><pre class="line-numbers language-js"><code class="language-js">xSchedulerRunning <span class="token operator">=</span> pdTRUE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>任务调度开始运行</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* If configGENERATE_RUN_TIME_STATS isdefined then the followingmacro must be defined to configure thetimer/counter used to generatethe run time counter time base. */</span><span class="token function">portCONFIGURE_TIMER_FOR_RUN_TIME_STATS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果<code>configGENERATE_RUN_TIME_STATS</code>使用时间统计功能，这个宏为<code>1</code>，那么用户必须实现一个宏<code>portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();</code>用来配置一个定时器或者计数器。</p><p>来到我们的重点了，开启任务调度，那么任务到这了就不会返回了。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">xPortStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/*Should not reach here as if the scheduler is running the    functionwill not return. */</span>                    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就能开启第一个任务了，感觉好难是吧，我一开始也是觉得的，但是写了这篇文章，觉得还行吧，也不算太难，可能也是在查看代码跟别人的书籍吧，写东西其实还是蛮好的，能加深理解，写过文章的人就知道，懂了不一定能写出来，所以，我还是很希望朋友们能投稿的。杰杰随时欢迎。。。</p><p>开始任务就按照套路模板添加自己的代码就好啦，很简单的。</p><p>先创建任务：</p><pre class="line-numbers language-js"><code class="language-js"> <span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t <span class="token punctuation">)</span>led0_task<span class="token punctuation">,</span>                  <span class="token punctuation">(</span><span class="token keyword">const</span> char<span class="token operator">*</span>    <span class="token punctuation">)</span><span class="token string">"led0_task"</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span>uint16_t       <span class="token punctuation">)</span>LED0_STK_SIZE<span class="token punctuation">,</span>              <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>          <span class="token punctuation">)</span>NULL<span class="token punctuation">,</span>                                                  <span class="token punctuation">(</span>UBaseType_t    <span class="token punctuation">)</span>LED0_TASK_PRIO<span class="token punctuation">,</span>                 <span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span>  <span class="token punctuation">)</span><span class="token operator">&amp;</span>LED0Task_Handler<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//创建LED1任务</span>  <span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t <span class="token punctuation">)</span>led1_task<span class="token punctuation">,</span>                  <span class="token punctuation">(</span><span class="token keyword">const</span> char<span class="token operator">*</span>    <span class="token punctuation">)</span><span class="token string">"led1_task"</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span>uint16_t       <span class="token punctuation">)</span>LED1_STK_SIZE<span class="token punctuation">,</span>              <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>          <span class="token punctuation">)</span>NULL<span class="token punctuation">,</span>              <span class="token punctuation">(</span>UBaseType_t    <span class="token punctuation">)</span>LED1_TASK_PRIO<span class="token punctuation">,</span>              <span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span>  <span class="token punctuation">)</span><span class="token operator">&amp;</span>LED1Task_Handler<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建完任务就开启任务调度：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token number">1</span><span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//开启任务调度</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后具体实现任务函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//LED0任务函数</span><span class="token keyword">void</span> <span class="token function">led0_task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       LED0<span class="token operator">=</span><span class="token operator">~</span>LED0<span class="token punctuation">;</span>       <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//LED1任务函数</span><span class="token keyword">void</span> <span class="token function">led1_task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       LED1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>       <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       LED1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好啦，今天的介绍到这了为止，后面还会持续更新，敬请期待哦~</p><p>欢迎大家一起来讨论操作系统的知识</p><p>我们的群号是：783234154</p><p><img src="http://jiejie01.top/%E6%AC%A2%E8%BF%8E%E5%85%B3%E6%B3%A8%E6%88%91%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="欢迎关注我公众号"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从单片机到操作系统-1</title>
      <link href="/freertos-1/"/>
      <url>/freertos-1/</url>
      
        <content type="html"><![CDATA[<p>我们知道，（单核）单片机某一时刻只能干一件事，会造成单片机资源的浪费，而且还有可能响应不够及时，所以，在比较庞大的程序或者是要求实时性比较高的情况下，我们可以移植操作系统。因为这种情况下操作系统比裸机方便很多，效率也高。下面，杰杰将带你们走进FreeRTOS的世界随便看看。</p><p>下面正式开始本文内容。</p><p>在没有用到操作系统之前，单片机的运行是顺序执行，就是说，很多时候，单片机在执行这件事的时候，无法切换到另一件事。这就造成了资源的浪费，以及错过了突发的信号。那么，用上了操作系统的时候，很容易避免了这样的问题。</p><p>很简单，从感觉上，单片机像是同时在干多件事，为什么说像呢，因为单片机的执行速度很快，快到我们根本没办法感觉出来，但是同时做两件事是不可能的，在（单核）单片机中，因为它的硬件结构决定了CPU只能在一个时间段做一件事如：<br><img src="http://jiejie01.top/freertos-1.jpg" alt="not os"></p><p>如这张图，都是按照顺序来执行这些事的，假设每个任务（事件）的time无限小，小到我们根本没法分辨出来，那么我们也会感觉单片机在同时做这六件事。</p><p>真相就是：所有任务都好像在执行，但实际上在任何一个时刻都只有一个任务在执行</p><p>如是加上了中断系统的话，就可以将上图理解为下图：<br><img src="http://jiejie01.top/freertos2.png" alt="os"></p><p>通常把程序分为两部分：前台系统和后台系统。 简单的小系统通常是前后台系统，这样的程序包括一个死循环和若干个中断服务程序：应用程序是一个无限循环，循环中调用API函数完成所需的操作，这个大循环就叫做后台系统。中断服务程序用于处理系统的异步事件，也就是前台系统。前台是中断级，后台是任务级。简单来说就是程序一直按顺序执行，有中断来了就做中断（前台）的事情。处理完中断（前台）的事情，就回到大循环（后台）继续按顺序执行。</p><p>那么问题来了，这样子的系统肯定不是好的系统，我在做第一个任务的时候想做第四个任务，根本做不到啊，其实也能做到，让程序执行的指针cp指向第四个任务就行了。但是任务一旦复杂，那么整个工程的代码的结构，可移植性，及可读性，肯定会差啦。</p><p> FreeRTOS</p><p>那么操作系统的移植就是不可或缺的了。什么叫RTOS？：Real Time OS，实时操作系统，强调的是实时性，就是要规定什么时间该做什么任务。那么假如同一个时刻，需要执行两个或者多个任务怎么办。那么我们可以人为地把任务划分优先级，哪个任务重要，就先做，因为前面一直强调，单片机无法同时做两件事，在某一个时刻只能做一件事。</p><p>那么FreeRTOS是怎么操作的呢？先看看FreeRTOS的内核吧：</p><p>FreeRTOS是一个可裁剪、可剥夺型的多任务内核，而且没有任务数限制。FreeRTOS提供了实时操作系统所需的所有功能，包括资源管理、同步、任务通信等。 FreeRTOS是用C和汇编来写的，其中绝大部分都是用C语言编写的，只有极少数的与处理器密切相关的部分代码才是用汇编写的，FreeRTOS结构简洁，可读性很强！RTOS的内核负责管理所有的任务，内核决定了运行哪个任务，何时停止当前任务切换到其他任务，这个是内核的多任务管理能力。</p><p>可剥夺内核顾名思义就是可以剥夺其他任务的CPU使用权，它总是运行就绪任务中的优先级最高的那个任务。<br><img src="http://jiejie01.top/freertos3.png" alt="freertos"></p><p>在FreeRTOS中，每个任务都是无限循环的，一般来说任务是不会结束运行的，也不允许有返回值，任务的结构一般都是</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">While</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/****一直在循环执行*****/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果不需要这个任务了，那就把它删除。</p><p>移植的教程我就不写了，超级简单的，按照已有的大把教程来做就行了。（如果没有资源，可以在后台找我，我给一份移植的教程/源码）</p><p>其实FreeRTOS的运用及其简单，移植成功按照自己的意愿来配置即可，而且FreeRTOS有很多手册，虽然作者英语很差，但是我有谷歌翻译！！！哈哈哈</p><p>既然一直都说任务任务，那肯定要有任务啊，创建任务：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// task. h  task.c</span>BaseType_t <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>      TaskFunction_t pvTaskCode<span class="token punctuation">,</span>                              <span class="token keyword">const</span> char <span class="token operator">*</span> <span class="token keyword">const</span> pcName<span class="token punctuation">,</span>                              uint16_t usStackDepth<span class="token punctuation">,</span>                              <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">,</span>                              UBaseType_t uxPriority<span class="token punctuation">,</span>                              TaskHandle_t <span class="token operator">*</span>pvCreatedTask                          <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数的原型都有，按照字面的理解</p><pre class="line-numbers language-js"><code class="language-js">TaskFunction_t pvTaskCode        <span class="token comment" spellcheck="true">//传递进来的是任务函数</span><span class="token keyword">const</span> char <span class="token operator">*</span> <span class="token keyword">const</span> pcName         <span class="token comment" spellcheck="true">//传递进来的是任务Name</span>uint16_t usStackDepth            <span class="token comment" spellcheck="true">//传入的是堆栈的大小</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在这里要说明一下，在裸机中开发，我们不管局部变量还是全局变量，反正定义了就能用，中断发生时，函数返回地址发哪里，我们也不管。但是在操作系统中，我们必须弄清楚我们的参数是怎么储存的，他们的大小是多大，就需要我们去定义这个堆栈的大小。它就是用来存放我们的这些东西的。太小，导致堆栈溢出，发生异常。（栈是单片机 RAM 里面一段连续的内存空间）</p><p>因为在多任务系统中，每个任务都是独立的，互不干扰的，所以要为每个任务都分配独立的栈空间。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters              <span class="token comment" spellcheck="true">//传递给任务函数的参数</span>UBaseType_t uxPriority          <span class="token comment" spellcheck="true">//任务优先级</span>TaskHandle_t <span class="token operator">*</span>pvCreatedTask     <span class="token comment" spellcheck="true">//任务句柄</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>任务句柄也是很重要的东西，我们怎么删除任务也是要用到任务句柄，其实说白了，我操作系统怎么知道你是什么任务，靠的就是任务句柄的判断，才知道哪个任务在执行，哪个任务被挂起。下一个要执行的任务是哪个等等，靠的都是任务句柄。</p><p>那么要使用这些东西，我们肯定要实现啦，下面就是实现的定义，要定义优先级，堆栈大小，任务句柄，任务函数等。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//任务优先级</span>#define LED_TASK_PRIO           <span class="token number">2</span><span class="token comment" spellcheck="true">//任务堆栈大小     </span>#define LED_STK_SIZE             <span class="token number">50</span><span class="token comment" spellcheck="true">//任务句柄</span>TaskHandle_t LED_Task_Handler<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//任务函数</span><span class="token keyword">void</span> <span class="token function">LED_Task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建任务后，可以开启任务调度了，然后系统就开始运行。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t <span class="token punctuation">)</span>LED_Task<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//任务函数</span>            <span class="token punctuation">(</span><span class="token keyword">const</span> char<span class="token operator">*</span>    <span class="token punctuation">)</span><span class="token string">"led_task"</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">//任务名称</span>            <span class="token punctuation">(</span>uint16_t       <span class="token punctuation">)</span>LED_STK_SIZE<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//任务堆栈大小</span>            <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>          <span class="token punctuation">)</span>NULL<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//传递给任务函数的参数</span>            <span class="token punctuation">(</span>UBaseType_t    <span class="token punctuation">)</span>START_TASK_PRIO<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//任务优先级</span>            <span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span>  <span class="token punctuation">)</span><span class="token operator">&amp;</span>LED_Task_Handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//任务句柄 </span> <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//开启任务调度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个创建任务的函数 xTaskCreate 是有返回值的，其返回值的类型是BaseType_t。</p><p>我们在描述中看看：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// @return pdPASS if the task was successfully created and added to a readylist, otherwise an error code defined in the file projdefs.h</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们其实可以在任务调度的时候判断一下返回值是否为pdPASS从而知道任务创是否建成功。并且打印一个信息作为调试。因为后面使用信号量这些的时候都要知道信号量是否创建成功，使得代码健壮一些。免得有隐藏的bug。</p><p>然后就是具体实现我们的任务LED_Task是在做什么的</p><p>当然可以实现多个任务。还是很简单的。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//LED任务函数</span><span class="token keyword">void</span> <span class="token function">LED_Task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        LED0  <span class="token operator">=</span>  <span class="token operator">!</span>LED0<span class="token punctuation">;</span>        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是一个简单的操作系统的概述。</p><p>下一篇，应该是讲述开启任务调度与任务切换的具体过程。</p><p>这个可以参考野火的书籍《从 0 到 1 教你写 uCOS-III》</p><p><img src="http://jiejie01.top/%E6%AC%A2%E8%BF%8E%E5%85%B3%E6%B3%A8%E6%88%91%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="欢迎关注我公众号"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openmv学习之旅-2</title>
      <link href="/openmv-2/"/>
      <url>/openmv-2/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是杰杰。</p><p>从上一篇openmv的学习中<a href="https://jiejietop.gitee.io/openmv-1/" target="_blank" rel="noopener">openmv学习之旅-1</a></p><p>我们可以很简单运用micropython在openmv上做我们想做的事情。</p><p>Python这个东西用起来是很简单的，，下面来说说改善色块追踪的算法</p><p>先做个改善前的分析吧：</p><p>改善前：</p><pre class="line-numbers language-js"><code class="language-js">API：find_blobs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>thresholds</code> 是颜色的阈值。这个参数是一个列表，可以包含多个颜色。在返回的色块对象blob可以调用code方法，来判断是什么颜色的色块。</p><p><code>roi</code> 是“感兴趣区”。</p><p><code>x_stride</code> 就是查找的色块的x方向上最小宽度的像素，默认为2。</p><p><code>y_stride</code> 就是查找的色块的y方向上最小宽度的像素，默认为1。</p><p><code>area_threshold</code> 面积阈值，如果色块被框起来的面积小于这个值，会被过滤掉。</p><p><code>pixels_threshold</code> 像素个数阈值，如果色块像素数量小于这个值，会被过滤掉</p><p><code>merge</code> 合并，如果设置为True，那么合并所有重叠的blob为一个。 注意：这会合并所有的blob，无论是什么颜色的。如果你想混淆多种颜色的blob，只需要分别调用不同颜色阈值的find_blobs。</p><pre class="line-numbers language-js"><code class="language-js">blobs <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token function">find_blobs</span><span class="token punctuation">(</span><span class="token punctuation">[</span>red<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>find_blobs</code> 对象返回的是多个 <code>blob</code> 的列表。<br>而一个 <code>blobs</code> 列表里包含很多 <code>blob</code> 对象， <code>blobs</code> 对象就是色块，每个 <code>blobs</code> 对象包含一个色块的信息。</p><p>blob有多个方法：</p><p><code>blob.rect()</code> 返回这个色块的外框——矩形元组(x, y, w, h)，可以直接在image.draw_rectangle中使用。</p><p><code>blob.x()</code> 返回色块的外框的x坐标（int），也可以通过blob[0]来获取。</p><p><code>blob.y()</code>返回色块的外框的y坐标（int），也可以通过blob[1]来获取。</p><p><code>blob.w()</code>返回色块的外框的宽度w（int），也可以通过blob[2]来获取。</p><p><code>blob.h()</code>返回色块的外框的高度h（int），也可以通过blob[3]来获取。</p><p><code>blob.pixels()</code> 返回色块的像素数量（int），也可以通过blob[4]来获取。</p><p><code>blob.cx()</code> 返回色块的外框的中心x坐标（int），也可以通过blob[5]来获取。</p><p><code>blob.cy()</code> 返回色块的外框的中心y坐标（int），也可以通过blob[6]来获取。</p><p><code>blob.rotation()</code>返回色块的旋转角度（单位为弧度）（float）。如果色块类似一个铅笔，那么这个值为0-180°。如果色块是一个圆，那么这个值是无用的。如果色块完全没有对称性，那么你会得到0-360°，也可以通过blob[7]来获取。</p><p><code>blob.code()</code>返回一个16bit数字，每一个bit会对应每一个阈值。</p><p>（上面的知识在openmv的官网上都有说明）</p><p>下面是说说调用find_blobs来做色块的追踪的原理</p><p>它是全幅图像扫描，它有优点也有缺点</p><p>先说说优点吧:信息全面，全幅图像的搜索，把所有色块都搜索进来了</p><p>但是缺点也不少：①：运算的速度，是很慢的，有些地方我们根本不需要扫描它。</p><p>②：色块的数量，很多时候，会有很多延时差不多的色块过来干扰，导致追踪失败。</p><p>源码：</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">import</span> sensor<span class="token punctuation">,</span> image<span class="token punctuation">,</span> time red_threshold_01 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span> sensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span> sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QVGA<span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>set_auto_whitebal<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span> clock <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>    img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>     blobs <span class="token operator">=</span> img<span class="token punctuation">.</span>find_blobs<span class="token punctuation">(</span><span class="token punctuation">[</span>red_threshold_01<span class="token punctuation">]</span><span class="token punctuation">,</span>                             area_threshold<span class="token operator">=</span><span class="token number">150</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> blobs<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#如果找到了目标颜色</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>blobs<span class="token punctuation">)</span>        <span class="token keyword">for</span> b <span class="token keyword">in</span> blobs<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#迭代找到的目标颜色区域</span>            <span class="token comment" spellcheck="true"># Draw a rect around the blob.</span>            img<span class="token punctuation">.</span>draw_rectangle<span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># rect</span>            <span class="token comment" spellcheck="true">#用矩形标记出目标颜色区域</span>            img<span class="token punctuation">.</span>draw_cross<span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># cx, cy</span>            <span class="token comment" spellcheck="true">#在目标颜色区域的中心画十字形标记</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果图：<br><img src="http://jiejie01.top/openmv1.png" alt="openmv1"></p><p>运算速度：<br><img src="http://jiejie01.top/openmv2.png" alt="openmv2"></p><p>从拍摄完到扫描完，每秒只能处理二十多帧图像，而且是简单的处理。</p><p>虽然脱机运行速度可以快一倍。但是还是比较慢的。</p><p>肯定要改进啊。</p><p>以下是改进扫描算法的思想：</p><p>①：首先做一次全幅图像的扫描，找到我们需要的色块。</p><p>②：我们得到色块的信息：如色块的长、宽、及色块的位置</p><p>③：我们只扫描色块周围的区域（ROI）</p><p>④：假设在新的ROI找不到我们需要的色块，就重新来。</p><p>这个方法类似于飞思卡尔的边缘检测。</p><p>其实这个改进是非常简单的。因为我们需要的东西在microPython中全部都有。</p><p>只需要拿到find_blobs的返回的东西就好啦。</p><p>算法示意图<br><img src="http://jiejie01.top/openmv3.jpg" alt="openmv3"></p><p>绿色的是我们追踪的色块，</p><p>而红色的框是我们第一次全局扫描得到的东西</p><p>那么我们只需在红色的框之外做一次扫描就能得到绿色块啦</p><p>实现的源码</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">import</span> sensor<span class="token punctuation">,</span> image<span class="token punctuation">,</span> time <span class="token comment" spellcheck="true">#red_threshold_01 = (45, 100, -60, 80, 34, 91)</span> red_threshold_01 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">72</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">)</span> sensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span> sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QVGA<span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>set_auto_whitebal<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#关闭白平衡。白平衡是默认开启的，在颜色识别中，需要关闭白平衡</span>clock <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span> img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>blobs <span class="token operator">=</span> img<span class="token punctuation">.</span>find_blobs<span class="token punctuation">(</span><span class="token punctuation">[</span>red_threshold_01<span class="token punctuation">]</span><span class="token punctuation">,</span>                         area_threshold<span class="token operator">=</span><span class="token number">150</span><span class="token punctuation">)</span>last_blobs <span class="token operator">=</span> blobs<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>     img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> last_blobs<span class="token punctuation">:</span>         <span class="token keyword">for</span> b <span class="token keyword">in</span> blobs<span class="token punctuation">:</span>            x1 <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">7</span>            y1 <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">7</span>            w1 <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">12</span>            h1 <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">12</span>            <span class="token comment" spellcheck="true">#print(b.cx(),b.cy())</span>         roi2 <span class="token operator">=</span> <span class="token punctuation">(</span>x1<span class="token punctuation">,</span>y1<span class="token punctuation">,</span>w1<span class="token punctuation">,</span>h1<span class="token punctuation">)</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>roi2<span class="token punctuation">)</span>         blobs <span class="token operator">=</span> img<span class="token punctuation">.</span>find_blobs<span class="token punctuation">(</span><span class="token punctuation">[</span>red_threshold_01<span class="token punctuation">]</span><span class="token punctuation">,</span>                                    roi <span class="token operator">=</span> roi2<span class="token punctuation">,</span>                                    area_threshold<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span>         last_blobs <span class="token operator">=</span> blobs    <span class="token keyword">else</span><span class="token punctuation">:</span>        blobs <span class="token operator">=</span> img<span class="token punctuation">.</span>find_blobs<span class="token punctuation">(</span><span class="token punctuation">[</span>red_threshold_01<span class="token punctuation">]</span><span class="token punctuation">,</span>                                    area_threshold<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span>        last_blobs <span class="token operator">=</span> blobs    <span class="token keyword">if</span> last_blobs<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#如果找到了目标颜色</span>        <span class="token comment" spellcheck="true">#  print(blobs)</span>        <span class="token keyword">for</span> b <span class="token keyword">in</span> last_blobs<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#迭代找到的目标颜色区域</span>            img<span class="token punctuation">.</span>draw_rectangle<span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>             img<span class="token punctuation">.</span>draw_cross<span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"帧率 : "</span><span class="token punctuation">,</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改善后的帧率的确是快了不少的：基本能快一倍以上，当然，物体在图片越大，处理的速度会越慢。</p><p><img src="http://jiejie01.top/openmv4.png" alt="openmv4"></p><p>帧率达到了  45  ，并且，对于运动中的物体，也能很好的追踪出来，减少无关物体的干扰。</p><p>按照这个思想，我们还能把这个物体分成四条边来扫描：</p><p><img src="http://jiejie01.top/openmv5.jpg" alt="openmv5"></p><p>那么是不是只需要扫描到这个物体的四条边，并且证明四条边的点都有重合，那么，我们就能知道这个物体是一个整体从而得到物体的位置。。。。</p><p>当然，这只是想法。对于程序员任何的功能想法的实现都需要代码的实现，这代码我就不实现了，有兴趣的可以试试。。。</p><p><img src="http://jiejie01.top/%E6%AC%A2%E8%BF%8E%E5%85%B3%E6%B3%A8%E6%88%91%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="欢迎关注我公众号"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openmv学习之旅-1</title>
      <link href="/openmv-1/"/>
      <url>/openmv-1/</url>
      
        <content type="html"><![CDATA[<p>最近入手了个OpenMv。<br>装IDE这种小事就不说了。说说真正入门的操作吧。对Python也没啥要求。我也是这样子马上上手的，当然在过程我是学习了Python的。</p><h1 id="1：绘制矩形"><a href="#1：绘制矩形" class="headerlink" title="1：绘制矩形"></a>1：绘制矩形</h1><p>函数说明</p><pre class="line-numbers language-python"><code class="language-python">image<span class="token punctuation">.</span>draw_rectangle（rect_tuple，颜色<span class="token operator">=</span>白色）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数</p><p><code>rect_tuple</code></p><p>格式（x，y，w，h）</p><p>矩阵的起始坐标，（x，y），即矩形的左上角坐标</p><p><code>w</code>：矩形的宽度</p><p><code>h</code>：矩形的高度</p><p><code>x，y，w，h</code>均为整数</p><p><code>颜色</code></p><p>颜色，填入灰度值<code>（0-255）</code>，或者 RGB 值<code>（r，g，b）</code></p><h1 id="下面简单画个矩形"><a href="#下面简单画个矩形" class="headerlink" title="下面简单画个矩形"></a>下面简单画个矩形</h1><p><img src="http://jiejie01.top/openmv-1-openmv.png" alt="openmv-1-openmv"></p><h1 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h1><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sensor<span class="token punctuation">,</span> image<span class="token punctuation">,</span> timesensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true"># Reset and initialize the sensor.</span>sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Set pixel format to RGB565 (or GRAYSCALE)</span>sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QVGA<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Set frame size to QVGA (320x240)</span>sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Wait for settings take effect.</span>clock <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># Create a clock object to track the FPS.</span>x <span class="token operator">=</span> <span class="token number">100</span>y <span class="token operator">=</span> <span class="token number">100</span>width <span class="token operator">=</span> <span class="token number">100</span>height <span class="token operator">=</span> <span class="token number">100</span>rect_tuple <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span>rgb_white <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># (r=255, g=255, b=255) -> white color</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># Update the FPS clock.</span>    img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># Take a picture and return the image.</span>    img<span class="token punctuation">.</span>draw_string<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token string">"(%d, %d)"</span><span class="token operator">%</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span>rgb_white<span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_rectangle<span class="token punctuation">(</span>rect_tuple<span class="token punctuation">,</span> color<span class="token operator">=</span>rgb_white<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Note: OpenMV Cam runs about half as fast when connected</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是简单画矩形的图像，想要改变矩形位置就改变的x，y（图像左上角起点）</p><p>想要改变矩形面积就改变宽度，高度（图像宽＆高）改变线条颜色就改变 rgb_white</p><p>2：绘制十字</p><p>函数说明</p><pre class="line-numbers language-python"><code class="language-python">image<span class="token punctuation">.</span>draw_cross（x，y，size <span class="token operator">=</span> <span class="token number">5</span>，color <span class="token operator">=</span> White）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数</p><p><code>X</code></p><p>十字中心的 X 坐标</p><p><code>Y</code></p><p>十字中心的 y 坐标</p><p><code>尺寸</code></p><p>十字的长度</p><p><code>颜色</code></p><p>颜色，填入灰度值（0-255），或者 RGB 值（r，g，b）</p><p>样例代码</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sensor<span class="token punctuation">,</span> image<span class="token punctuation">,</span> timesensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true"># Reset and initialize the sensor.</span>sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Set pixel format to RGB565 (or GRAYSCALE)</span>sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QVGA<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Set frame size to QVGA (320x240)</span>sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Wait for settings take effect.</span>clock <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># Create a clock object to track the FPS.</span>x <span class="token operator">=</span> <span class="token number">150</span>y <span class="token operator">=</span> <span class="token number">150</span>size <span class="token operator">=</span> <span class="token number">20</span>rgb_white <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># (r=255, g=255, b=255) -> white color</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># Update the FPS clock.</span>    img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshotA<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># Take a picture and return the image.</span>    img<span class="token punctuation">.</span>draw_string<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token string">"(%d, %d)"</span><span class="token operator">%</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span>rgb_white<span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_cross<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> size<span class="token operator">=</span>size<span class="token punctuation">,</span> color<span class="token operator">=</span>rgb_white<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># Note: OpenMV Cam runs about half as fast when connected</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>学会简单画图，就可以使用 openmv 来做色彩追踪了。</p><p>未完待续……下篇用openmv来做色彩追踪</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机C语言知识用法之#define</title>
      <link href="/c-define/"/>
      <url>/c-define/</url>
      
        <content type="html"><![CDATA[<h1 id="define的定义："><a href="#define的定义：" class="headerlink" title="#define的定义："></a>#define的定义：</h1><p>#define是C语言中的一个预处理指令，其中的“#”表示这是一条预处理命令·。凡是以“#”开头的均为预处理命令，“define”为宏定义命令，“标识符”为所定义的宏名。</p><pre class="line-numbers language-js"><code class="language-js">#define TIME_NUM  <span class="token number">1000</span>  <span class="token comment" spellcheck="true">//定义一个时间数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一个简单的TIME_NUM 就定义好了，它代表1000，如果在程序里面写:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>TIME_NUM <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token punctuation">.</span>    <span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器在处理这个代码之前会对TIME_NUM 进行处理替换为1000。这样的定义看起来类似于普通的常量定义CONST，但也有着不同，因为define的定义更像是简单的文本替换，而不是作为一个量来使用。</p><h1 id="define的语法："><a href="#define的语法：" class="headerlink" title="#define的语法："></a>#define的语法：</h1><h2 id="语法一"><a href="#语法一" class="headerlink" title="语法一:"></a>语法一:</h2><pre class="line-numbers language-js"><code class="language-js">#define      标识符    被标识符代表的字符串      <span class="token comment" spellcheck="true">//这种用法很简单,就是一种替换.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="语法二"><a href="#语法二" class="headerlink" title="语法二:"></a>语法二:</h2><pre class="line-numbers language-js"><code class="language-js">#define     标识符<span class="token punctuation">[</span><span class="token punctuation">(</span>参数<span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>参数n<span class="token punctuation">)</span><span class="token punctuation">]</span>      被标识符代表的字符串        <span class="token comment" spellcheck="true">//其中,在 "被标识符代表的字符串" 中出现的形参将在使用时被实参替代. 就像写函数一样.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-js"><code class="language-js">#define    ADD_NUM     <span class="token number">10</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以这样子用:</p><pre class="line-numbers language-js"><code class="language-js">#define    <span class="token function">ADD</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>     <span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个定义就将返回两个数中较大的那个，看到了吗？<br>因为这个“函数”没有类型检查，就好像一个函数模板似的，当然，它绝对没有模板那么安全就是了。可以作为一个简单的模板来使用而已。<br>但是这样做的话存在隐患，例子如下：</p><pre class="line-numbers language-js"><code class="language-js">#define <span class="token function">ADD</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>   a<span class="token operator">+</span>b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在一般使用的时候是没有问题的，但是如果遇到如：c <em> Add(a,b) </em> d的时候就会出现问题，代数式的本意是a+b然后去和c，d相乘，但是因为使用了define（它只是一个简单的替换），所以式子实际上变成了  c<em>a + b</em>d 所以，用#define要注意顺序</p><p>一般我个人用#define在单片机程序上的话，我一般只做简单的替换。</p><pre class="line-numbers language-js"><code class="language-js">#define TIME_NUM   <span class="token punctuation">(</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">24</span><span class="token punctuation">)</span>UL<span class="token comment" spellcheck="true">//定义一个一天时间有多少秒</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外举一个例子：</p><pre class="line-numbers language-js"><code class="language-js">#define pin <span class="token punctuation">(</span>int<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pin a<span class="token punctuation">,</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>本意是a和b都是int型指针，但是实际上变成int* a,b;<br>a是int型指针，而b是int型变量。<br>这是应该使用typedef来代替define，这样a和b就都是int型指针了。<br>所以我们在定义的时候，养成一个良好的习惯，建议所有的层次都要加括号。</p><p>而且，宏在单片机代码中用的很多，常数的替换、地址的偏移，等等都用得上<br>用宏来修改移植代码更加便捷，代码更容易使人读懂。。。。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hellolo world</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="hello"><a href="#hello" class="headerlink" title="hello"></a>hello</h1><blockquote><p>网络的好朋友，你好，我是杰杰！如果我的博客有什么不足的地方，欢迎向我反馈；如果我的博客对你有帮助，那是我的荣幸！如果觉得文章很好，欢迎动动小手指，点个赞或者转发        —–杰杰。</p></blockquote><p>欢迎关注我个人微信公众号，来一起全栈开发~<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ppZWppZTAxLnRvcC9Mb2dvL0daLnBuZw?x-oss-process=image/format,png" alt=""></p><h1 id="网络协议栈-【推荐】"><a href="#网络协议栈-【推荐】" class="headerlink" title="网络协议栈 【推荐】"></a>网络协议栈 【推荐】</h1><ol><li><a href="https://blog.csdn.net/jiejiemcu/article/details/85233198" target="_blank" rel="noopener">lwip源码下载地址</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88024614" target="_blank" rel="noopener">TCP/IP协议栈扫盲班</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88204770" target="_blank" rel="noopener">网络底层知识</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88406088" target="_blank" rel="noopener">ARP协议原理</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88879553" target="_blank" rel="noopener">LwIP中的ARP实现（1）之ARP缓存表的数据结构</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88887437" target="_blank" rel="noopener">LwIP中的ARP实现（2）之ARP缓存表的超时处理</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88887466" target="_blank" rel="noopener">LwIP中的ARP实现（3）之发送ARP请求包</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88887494" target="_blank" rel="noopener">LwIP中的ARP实现（4）之ARP数据包接收</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88887520" target="_blank" rel="noopener">LwIP中的ARP实现（5）之ARP数据包发送 </a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/89072812" target="_blank" rel="noopener">IP协议基础扫盲班</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/89072834" target="_blank" rel="noopener">IP地址相关知识深入了解~</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/89072573" target="_blank" rel="noopener">IP数据报格式分析</a></li></ol><p>未完待续…</p><h1 id="RTOS操作系统相关"><a href="#RTOS操作系统相关" class="headerlink" title="RTOS操作系统相关"></a>RTOS操作系统相关</h1><ol><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/86701792" target="_blank" rel="noopener">FreeRTOS移植——基于stm32f1</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80308052" target="_blank" rel="noopener">【连载】从单片机到操作系统③——走进FreeRTOS</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80463911" target="_blank" rel="noopener">【连载】从单片机到操作系统④——FreeRTOS创建任务&amp;开启调度详解</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80637559" target="_blank" rel="noopener">【连载】从单片机到操作系统⑤——FreeRTOS列表&amp;列表项的源码解读</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/81039707" target="_blank" rel="noopener">【连载】从单片机到操作系统⑥——FreeRTOS任务切换机制详解</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/81515788" target="_blank" rel="noopener">【连载】从单片机到操作系统⑦——深入了解FreeRTOS的延时机制</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82534974" target="_blank" rel="noopener">RTOS的临界段知识详解</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/86715766" target="_blank" rel="noopener">FreeRTOS消息队列</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/87174666" target="_blank" rel="noopener">FreeRTOS优化与错误排查方法</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/84778522" target="_blank" rel="noopener">继续学习FreeRTOS~</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82588304" target="_blank" rel="noopener">RT-Thread内核实现的思维导图——线程&amp;调度器</a></p><p>未完待续…</p></li></ol><h1 id="STM8"><a href="#STM8" class="headerlink" title="STM8"></a>STM8</h1><ol><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80543012" target="_blank" rel="noopener"> STM8L051F3_0d_基础介绍</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80219795" target="_blank" rel="noopener">STM8L051F3_0b_开发环境搭建</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80219830" target="_blank" rel="noopener">STM8L051F3_0c_新建工程</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80543043" target="_blank" rel="noopener">STM8L051F3_01_GPIO应用</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80574810" target="_blank" rel="noopener">STM8L051F3_02_EXTI应用</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80629051" target="_blank" rel="noopener">STM8L051F3_03_CLK应用</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80659610" target="_blank" rel="noopener">STM8L051F3_04_PWR应用</a></li></ol><p>未完待续…</p><h1 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h1><ol><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80179096" target="_blank" rel="noopener">【干货】老外的GitHub整理的stm32f4驱动库</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80542667" target="_blank" rel="noopener">【重写】简析stm32启动过程</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80563422" target="_blank" rel="noopener">STM32进阶之串口环形缓冲区实现</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80565426" target="_blank" rel="noopener">嵌入式重定向 printf</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82227824" target="_blank" rel="noopener">数据处理相关源码</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82743945" target="_blank" rel="noopener">STM32之串口DMA接收不定长数据</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82898387" target="_blank" rel="noopener">基于Linux的kfifo移植到STM32（支持os的互斥访问）</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/83685631" target="_blank" rel="noopener">纯C语言写的按键驱动，将按键逻辑与按键处理事件分离~</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/83932913" target="_blank" rel="noopener">一种Cortex-M内核中的精确延时方法</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/87615397" target="_blank" rel="noopener">CmBacktrace: ARM Cortex-M 系列 MCU 错误追踪库</a></p><p>未完待续…</p></li></ol><h1 id="学习随笔"><a href="#学习随笔" class="headerlink" title="学习随笔"></a>学习随笔</h1><ol><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82049104" target="_blank" rel="noopener">git常用命令</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82262712" target="_blank" rel="noopener">vs code 随笔</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82430157" target="_blank" rel="noopener">STM32等处理器的MDK离线支持包下载地址</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/84857382" target="_blank" rel="noopener">mdk5.26、5.27下载地址</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/85165949" target="_blank" rel="noopener">mdk工程的批量操作文件</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/87340868" target="_blank" rel="noopener">PDF Drive</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/87904149" target="_blank" rel="noopener">基于腾讯云Ubuntu主机搭建ghost</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/88097620" target="_blank" rel="noopener">基于ubuntu腾讯云主机搭建书库</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/88070640" target="_blank" rel="noopener">http客户端</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80543529" target="_blank" rel="noopener">基于小程序、单片机与PLC组合的共享车库信息平台平台【已经实现】</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/79307249" target="_blank" rel="noopener">超声波测距原理与实现</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/79469682" target="_blank" rel="noopener">openmv学习之旅①</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80579893" target="_blank" rel="noopener">openmv学习之旅②之色块追踪算法的改善</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80537935" target="_blank" rel="noopener">【野火®】i.MX RT1052评测——移植RT-Thread</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80495612" target="_blank" rel="noopener">开源一个串口上位机源码</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80543069" target="_blank" rel="noopener">win10 64位JLink v8固件丢失修复经验</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/79307319" target="_blank" rel="noopener">如何阅读看懂datasheet</a></p><p>未完待续…</p></li></ol><h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><ol><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80861760" target="_blank" rel="noopener">C语言字符串匹配与数据提取源码</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/79307332" target="_blank" rel="noopener">单片机C语言知识用法之#define</a></p><p>未完待续…</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
